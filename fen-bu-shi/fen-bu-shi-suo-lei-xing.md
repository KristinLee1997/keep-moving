# 分布式锁类型

## 一、前言

### 1.为什么使用分布式锁？

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API\(如ReentrantLock或Synchronized\)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！

### 2.分布式锁应具备的条件

1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；
2. 高可用的获取锁与释放锁；
3. 高性能的获取锁与释放锁；
4. 具备可重入特性；
5. 具备锁失效机制，防止死锁；
6. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

## 二、分布式锁的实现方式

### 1.数据库

#### 实现思想：

在数据库中创建一个表，表中包含**方法名**等字段，并在**方法名字段上创建唯一索引**，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁

#### 存在问题：

* 实现复杂。因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；
* 不具备可重入的特性。因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；
* 没有锁失效机制。因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；
* 不具备阻塞锁特性。获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。
* 在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。

### 2.Redis

#### 实现思想：

* 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。
* 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
* 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

#### 解决的问题：

* 实现可重入性。在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者。
* 实现锁失效机制。redis支持传入失效时间。
* 实现阻塞锁，可以使用while循环多次尝试获取锁。

#### 存在问题：

* 失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。

### 3.Zookeeper

#### 实现思想：

利用Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

#### 解决的问题：

* 解决锁无法释放问题。因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。
* 实现阻塞锁。使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。
* 实现可重入锁。使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。

#### 存在问题：

因为需要频繁的创建和删除节点，性能上不如Redis方式。

### 4.ETCD



### 三、分布式锁实现方式的比较

#### 1.理解的难易程度

数据库 &gt; 缓存 &gt; Zookeeper

#### 2.实现的复杂性角度

Zookeeper &gt;= 缓存 &gt; 数据库

#### 3.性能角度

缓存 &gt; Zookeeper &gt;= 数据库

#### 4.可靠性角度

Zookeeper &gt; 缓存 &gt; 数据库







































